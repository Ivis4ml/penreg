% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/10_admm_bp.R
\name{admm_bp}
\alias{admm_bp}
\title{Fitting A Basis Pursuit Model Using ADMM Algorithm}
\usage{
admm_bp(x, y, ...)
}
\arguments{
\item{x}{The transformation matrix}

\item{y}{The transformed vector to recover from}
}
\description{
Basis Pursuit is an optimization problem that minimizes
\eqn{\Vert \beta \Vert_1}{||\beta||_1} subject to
\eqn{y=X\beta}{y = X * \beta}. Here \eqn{X} is an \eqn{n} by \eqn{p}
matrix with \eqn{p > n}. Basis Pursuit is broadly applied in Compressed
Sensing to recover a sparse vector \eqn{\beta} from the transformed
lower dimensional vector \eqn{y}.

This function will not directly conduct the computation,
but rather returns an object of class "\code{ADMM_BP}" that contains
several memeber functions to actually constructs and fits the model.

Member functions that are callable from this object are listed below:

\tabular{ll}{
  \code{$opts()}     \tab Setting additional options. See section
                          \strong{Additional Options} for details.\cr
  \code{$fit()}      \tab Fit the model and do the actual computation.
                          See section \strong{Model Fitting} for details.
}
}
\section{Additional Options}{

Additional options related to ADMM algorithm can be set through the
\code{$opts()} member function of an "\code{ADMM_BP}" object. The usage of
this method is

\preformatted{    model$opts(maxit = 10000, eps_abs = 1e-4, eps_rel = 1e-4,
               rho = NULL)
}

Here \code{model} is the object returned by \code{admm_bp()}.
Explanation of the arguments is given below:

\describe{
\item{\code{maxit}}{Maximum number of iterations.}
\item{\code{eps_abs}}{Absolute tolerance parameter.}
\item{\code{eps_rel}}{Relative tolerance parameter.}
\item{\code{rho}}{ADMM step size parameter. If set to \code{NULL}, the program
                  will compute a default one.}
}

This member function will implicitly return the "\code{ADMM_BP}" object itself.
}

\section{Model Fitting}{

Model will be fit after calling the \code{$fit()} member function. This is no
argument that needs to be set. The function will return an object of class
"\code{ADMM_BP_fit}", which contains the following fields:

\describe{
\item{\code{beta}}{The recovered \eqn{\beta} vector in sparse form.}
\item{\code{niter}}{Number of ADMM iterations.}
}

Class "\code{ADMM_BP_fit}" also contains a \code{$plot()} member function,
which plots the coefficients against their indices. See the examples below.
}
\examples{
## An Compressed Sensing example ##

## Create a sparse signal vector
set.seed(123)
n = 50
p = 100
nsig = 15
beta_true = c(runif(nsig), rep(0, p - nsig))
beta_true = sample(beta_true)

## Generate the transformation matrix and the compressed vector
x = matrix(rnorm(n * p), n, p)
y = drop(x \%*\% beta_true)

## Build the model
model = admm_bp(x, y)

## Request a higher precision
model$opts(eps_rel = 1e-5)

## Fit the model
res = model$fit()
res

## Plot for the recovered vector
res$plot()

## The steps above can be accomplished using a chainable call
admm_bp(x, y)$opts(eps_rel = 1e-5)$fit()$plot()

## Compare the true beta and the recovered one
library(ggplot2)
g = res$plot()
d = data.frame(ind = seq_along(beta_true),
               coef = beta_true)
g + geom_segment(aes(x = ind + 0.5, xend = ind + 0.5,
                     y = coef, yend = 0), data = d, color = "red")
}
\author{
Yixuan Qiu <\url{http://statr.me}>
}

